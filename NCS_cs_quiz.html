<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>NCS 공기업 전산직 CS 퀴즈</title>
  <h1>NCS 공기업 전산직 CS 퀴즈 </h1>
  <h2> (데이터베이스, 소프트웨어공학, 운영체계, 정보보안, 컴퓨터네트워크) </h2>h2>
  <h2>새로고침 시 순서가 바뀌어요! 문제의 내용과 번호는 중복이 될 수 있습니다! </h2>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; padding: 20px; }
    .question { background: white; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; padding: 16px; }
    .question h3 { margin-top: 0; }
    .options label { display: block; margin: 5px 0; cursor: pointer; }
    .answer { display: none; margin-top: 10px; color: #c00; }
    .correct { color: red; font-weight: bold; }
    #score { font-size: 20px; font-weight: bold; margin-top: 30px; }
    button { margin-top: 10px; padding: 6px 12px; cursor: pointer; }
  </style>
</head>
<body>

  <div id="quiz-container"></div>

  <button id="check-all">결과 보기</button>
  <div id="score"></div>

  <script>
    const quizData = window.quizData || [
  {
    "number": 1,
    "question": "데이터 독립성과 가장 관계가 깊은 것은?",
    "options": [
      "동시성 제어",
      "스키마",
      "무결성 제약 조건",
      "트랜잭션"
    ],
    "answer": 2,
    "explanation": "스키마는 데이터의 구조를 정의하고 응용 프로그램과 데이터베이스 사이의 추상 계층을 제공하기 때문에 데이터 독립성과 관련이 깊습니다."
  },
  {
    "number": 2,
    "question": "다음 중 데이터베이스 언어에 해당하지 않는 것은?",
    "options": [
      "DDL",
      "DML",
      "DCL",
      "DSL"
    ],
    "answer": 4,
    "explanation": "DSL(Domain Specific Language)은 특정 영역에 맞춰 설계된 언어로 데이터베이스 언어에 포함되지 않습니다【779700311571655†L16-L19】."
  },
  {
    "number": 3,
    "question": "트랜잭션의 성질 중 ‘일관성(Consistency)’에 해당하는 설명은?",
    "options": [
      "트랜잭션은 전부 수행되거나 전혀 수행되지 않아야 한다.",
      "트랜잭션이 실행되기 전과 후의 데이터베이스는 항상 일관되어야 한다.",
      "동시에 여러 트랜잭션이 실행되면 데이터가 꼬일 수 있다.",
      "트랜잭션 실행 중 오류가 발생하면 복구해야 한다."
    ],
    "answer": 2,
    "explanation": "일관성은 트랜잭션 실행 전후에 데이터베이스가 모든 무결성 제약을 만족해야 함을 의미합니다【779700311571655†L18-L21】."
  },
  {
    "number": 4,
    "question": "트랜잭션의 특성 중 원자성(Atomicity)에 대한 설명으로 옳은 것은?",
    "options": [
      "트랜잭션 수행 결과는 항상 일관성을 유지해야 한다.",
      "트랜잭션은 고립되어 수행되어야 한다.",
      "트랜잭션은 전부 수행되거나 전혀 수행되지 않아야 한다.",
      "성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장되어야 한다."
    ],
    "answer": 3,
    "explanation": "원자성은 트랜잭션을 구성하는 모든 연산이 전부 수행되거나 전혀 수행되지 않는 ‘all‑or‑nothing’ 특성을 말합니다【486804134547013†L1-L2】."
  },
  {
    "number": 5,
    "question": "다음 중 제1정규형(1NF)의 특징으로 옳은 것은?",
    "options": [
      "속성 값이 원자값이어야 한다.",
      "이행적 종속 제거",
      "부분 함수 종속 제거",
      "다치 종속 제거"
    ],
    "answer": 1,
    "explanation": "1NF는 테이블의 각 속성 값이 더 이상 분해할 수 없는 원자값이어야 함을 요구합니다【779700311571655†L19-L21】."
  },
  {
    "number": 6,
    "question": "SQL문에서 테이블의 구조를 변경할 때 사용하는 명령어는?",
    "options": [
      "SELECT",
      "INSERT",
      "ALTER",
      "UPDATE"
    ],
    "answer": 3,
    "explanation": "ALTER 명령은 테이블에 열을 추가하거나 삭제하고 데이터 타입을 변경하는 등 구조를 수정하는 데 사용됩니다【790078507432601†L1-L2】."
  },
  {
    "number": 7,
    "question": "데이터베이스 트랜잭션에서 병행 제어가 필요한 이유는?",
    "options": [
      "성능 향상",
      "데이터 중복 방지",
      "무결성 보장",
      "동시에 수행되는 트랜잭션 간의 충돌 방지"
    ],
    "answer": 4,
    "explanation": "여러 트랜잭션이 동시에 실행될 때 일어날 수 있는 충돌을 방지하고 데이터 일관성을 유지하기 위해 병행 제어가 필요합니다【422747624936848†L1-L2】."
  },
  {
    "number": 8,
    "question": "다음 중 이상(Anomaly)의 유형이 아닌 것은?",
    "options": [
      "삽입 이상",
      "삭제 이상",
      "갱신 이상",
      "정렬 이상"
    ],
    "answer": 4,
    "explanation": "삽입·삭제·갱신 이상은 데이터 중복 및 불일치로 발생하는 대표적인 이상 현상이고, ‘정렬 이상’이라는 유형은 존재하지 않습니다【427048454652103†L3-L4】."
  },
  {
    "number": 9,
    "question": "SQL에서 데이터를 정렬할 때 사용하는 키워드는?",
    "options": [
      "ORDER BY",
      "GROUP BY",
      "HAVING",
      "SORT"
    ],
    "answer": 1,
    "explanation": "ORDER BY 절은 SELECT 문의 결과를 오름차순이나 내림차순으로 정렬할 때 사용합니다【360982841829634†L3-L4】."
  },
  {
    "number": 10,
    "question": "2단계 로킹 기법(Two‑phase Locking)의 목적은?",
    "options": [
      "데이터 중복 제거",
      "일관성 있는 백업",
      "동시성 제어와 데이터 일관성 유지",
      "성능 향상"
    ],
    "answer": 3,
    "explanation": "두 단계 로킹은 트랜잭션이 잠금과 해제를 순차적으로 수행하도록 하여 동시성 제어를 실현하고 데이터의 일관성을 보장합니다【779700311571655†L50-L52】."
  },
  {
    "number": 11,
    "question": "관계형 데이터베이스에서 기본키(Primary Key)의 역할은?",
    "options": [
      "데이터를 외부와 연결한다.",
      "데이터의 순서를 정한다.",
      "튜플을 고유하게 식별한다.",
      "데이터를 그룹화한다."
    ],
    "answer": 3,
    "explanation": "기본키는 테이블의 각 튜플을 고유하게 식별하기 위한 속성으로 사용됩니다【360982841829634†L2-L3】."
  },
  {
    "number": 12,
    "question": "데이터 무결성 제약 조건 중 외래키(Foreign Key)의 역할은?",
    "options": [
      "유일성 유지",
      "데이터 삽입 방지",
      "다른 테이블의 기본키를 참조",
      "속성 이름 제한"
    ],
    "answer": 3,
    "explanation": "외래키는 다른 테이블의 기본키 값을 참조하여 두 테이블 간의 관계를 정의하고 참조 무결성을 보장합니다【677880205694508†L164-L167】."
  },
  {
    "number": 13,
    "question": "관계 데이터베이스에서 사용되는 기본 용어가 아닌 것은?",
    "options": [
      "튜플(Tuple)",
      "애트리뷰트(Attribute)",
      "릴레이션(Relation)",
      "레지스터(Register)"
    ],
    "answer": 4,
    "explanation": "레지스터는 중앙처리장치(CPU) 내부의 기억 장치이며, 릴레이션 모델의 기본 구성 요소에 포함되지 않습니다【360982841829634†L3-L4】."
  },
  {
    "number": 14,
    "question": "데이터베이스에서 중복을 최소화하고 이상 현상을 제거하기 위한 과정은?",
    "options": [
      "트랜잭션",
      "정규화",
      "클러스터링",
      "암호화"
    ],
    "answer": 2,
    "explanation": "정규화는 테이블을 적절히 분해하여 데이터 중복을 줄이고 삽입·삭제·갱신 이상을 방지하기 위한 설계 기법입니다【427048454652103†L1-L2】."
  },
  {
    "number": 15,
    "question": "SQL에서 데이터를 검색하기 위한 명령어는?",
    "options": [
      "INSERT",
      "DELETE",
      "UPDATE",
      "SELECT"
    ],
    "answer": 4,
    "explanation": "SELECT 문은 테이블에서 원하는 데이터를 조회하기 위한 SQL 명령어입니다【360982841829634†L3-L4】."
  },
  {
    "number": 16,
    "question": "관계형 데이터베이스에서 튜플(Tuple)은 무엇을 의미하는가?",
    "options": [
      "테이블",
      "컬럼",
      "레코드",
      "스키마"
    ],
    "answer": 3,
    "explanation": "튜플은 테이블의 한 행을 나타내며 레코드라고도 합니다【912534476933719†L1-L2】."
  },
  {
    "number": 17,
    "question": "소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?",
    "options": [
      "품질 높은 소프트웨어 상품 개발",
      "지속적인 검증 시행",
      "결과에 대한 명확한 기록 유지",
      "최대한 많은 인력 투입"
    ],
    "answer": 4,
    "explanation": "소프트웨어 공학의 목표는 적절한 규모와 효율적인 팀 구성으로 품질을 높이는 것이며, 인력을 무작정 늘리는 것은 원칙이 아닙니다【185763542736909†L2-L3】."
  },
  {
    "number": 18,
    "question": "요구사항 정의 및 분석 설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램이 아닌 것은?",
    "options": [
      "Data Flow Diagram",
      "UML Diagram",
      "E‑R Diagram",
      "AVL Diagram"
    ],
    "answer": 4,
    "explanation": "AVL 트리는 균형 이진 탐색 트리 구조이며 요구사항 분석 모델링에서 사용되는 다이어그램이 아닙니다【779700311571655†L50-L54】."
  },
  {
    "number": 19,
    "question": "프로그램 언어의 특징 중 절차적 프로그래밍에 해당하는 것은?",
    "options": [
      "계속해서 모듈화된 구성",
      "이벤트 기반 처리",
      "데이터 중심 설계",
      "순차적 명령어 흐름"
    ],
    "answer": 4,
    "explanation": "절차지향 언어는 명령을 순서대로 수행하는 방식으로 프로그램을 구성하며 이벤트 기반 처리나 데이터 중심 설계는 이에 해당하지 않습니다【779700311571655†L50-L51】."
  },
  {
    "number": 20,
    "question": "소프트웨어 생명주기(SDLC)의 단계 중 시스템 구현 이후 단계는?",
    "options": [
      "요구 분석",
      "설계",
      "시험",
      "운영 및 유지보수"
    ],
    "answer": 4,
    "explanation": "시스템 구현 후에는 운영에 들어가며 버그 수정과 성능 향상 등을 위한 유지보수 단계가 이어집니다【736965116536844†L2-L3】."
  },
  {
    "number": 21,
    "question": "다음 중 객체지향 프로그래밍 언어가 아닌 것은?",
    "options": [
      "C++",
      "Java",
      "Python",
      "BASIC"
    ],
    "answer": 4,
    "explanation": "BASIC은 절차지향 언어로 객체지향 기능을 제공하지 않습니다【736965116536844†L0-L1】."
  },
  {
    "number": 22,
    "question": "소프트웨어 생명 주기에서 '유지보수' 단계의 주요 활동은?",
    "options": [
      "요구사항 정의",
      "설계 명세",
      "버그 수정 및 기능 개선",
      "테스트 계획 수립"
    ],
    "answer": 3,
    "explanation": "유지보수 단계는 발견된 오류를 수정하고 성능을 개선하며 사용자의 요구를 반영한 기능을 추가하는 활동을 포함합니다【779700311571655†L50-L52】."
  },
  {
    "number": 23,
    "question": "소프트웨어 공학에서 '모듈화'의 장점이 아닌 것은?",
    "options": [
      "재사용성 향상",
      "유지보수 용이",
      "복잡성 증가",
      "이해도 향상"
    ],
    "answer": 3,
    "explanation": "모듈화는 시스템을 작은 단위로 나누어 복잡도를 줄이기 때문에 복잡성 증가가 아니라 감소가 장점입니다【677880205694508†L0-L3】."
  },
  {
    "number": 24,
    "question": "객체지향의 4대 특성이 아닌 것은?",
    "options": [
      "캡슐화",
      "상속",
      "동기화",
      "다형성"
    ],
    "answer": 3,
    "explanation": "객체지향의 주요 특성은 캡슐화·상속·추상화·다형성이며, 동기화는 병렬 처리와 관련된 개념입니다【360982841829634†L64-L65】."
  },
  {
    "number": 25,
    "question": "다음 중 객체지향 프로그래밍의 특징이 아닌 것은?",
    "options": [
      "상속",
      "캡슐화",
      "추상화",
      "선형화"
    ],
    "answer": 4,
    "explanation": "객체지향의 핵심 특징은 상속·캡슐화·추상화·다형성이며, 선형화는 객체지향 개념에 포함되지 않습니다【736965116536844†L4-L4】."
  },
  {
    "number": 26,
    "question": "소프트웨어 개발 생명주기(SDLC)의 첫 번째 단계는?",
    "options": [
      "설계",
      "요구사항 분석",
      "구현",
      "테스트"
    ],
    "answer": 2,
    "explanation": "SDLC는 사용자의 요구를 수집하고 분석하는 요구사항 분석 단계로 시작합니다【900043030509575†L1-L2】."
  },
  {
    "number": 27,
    "question": "운영체제에서 프로세스 상태가 아닌 것은?",
    "options": [
      "대기(wait)",
      "실행(running)",
      "정지(stopped)",
      "저장(stored)"
    ],
    "answer": 4,
    "explanation": "프로세스는 실행, 준비, 대기, 종료 등으로 분류되며 '저장' 상태는 존재하지 않습니다【779700311571655†L16-L18】."
  },
  {
    "number": 28,
    "question": "다음 중 운영체제의 기능으로 볼 수 없는 것은?",
    "options": [
      "프로세서 관리",
      "기억장치 관리",
      "입출력 관리",
      "문서 편집"
    ],
    "answer": 4,
    "explanation": "문서 편집은 워드프로세서와 같은 응용 소프트웨어의 역할이며 운영체제의 기본 기능이 아닙니다【185763542736909†L1-L2】."
  },
  {
    "number": 29,
    "question": "시분할 시스템의 특징으로 알맞은 것은?",
    "options": [
      "하나의 작업만 처리",
      "동시에 여러 사용자 처리",
      "하나의 사용자만 사용",
      "오류율이 낮음"
    ],
    "answer": 2,
    "explanation": "시분할 시스템은 CPU 시간을 잘게 분할하여 여러 사용자나 작업이 번갈아 사용하도록 하는 운영체제 방식입니다【912534476933719†L1-L2】."
  },
  {
    "number": 30,
    "question": "운영체제에서 프로세스 간 자원 충돌을 방지하기 위한 기법은?",
    "options": [
      "데드락 회피",
      "교착 상태",
      "스케줄링",
      "인터럽트"
    ],
    "answer": 1,
    "explanation": "데드락 회피(Deadlock avoidance)는 시스템 상태를 미리 분석하여 교착 상태가 발생하지 않도록 자원 할당을 조정하는 기법입니다【900043030509575†L1-L2】."
  },
  {
    "number": 31,
    "question": "운영체제에서 다중 프로그래밍 환경의 장점으로 옳은 것은?",
    "options": [
      "응답 시간이 증가한다",
      "CPU 사용률이 감소한다",
      "시스템 자원을 효율적으로 사용할 수 있다",
      "하나의 작업만 처리할 수 있다"
    ],
    "answer": 3,
    "explanation": "다중 프로그래밍은 여러 프로그램을 메모리에 적재하여 CPU의 유휴 시간을 줄여 시스템 자원을 효율적으로 사용하는 데 목적이 있습니다【779700311571655†L60-L61】."
  },
  {
    "number": 32,
    "question": "운영체제에서 교착 상태(Deadlock)의 발생 조건으로 볼 수 없는 것은?",
    "options": [
      "상호 배제",
      "점유와 대기",
      "비선점",
      "무한 루프"
    ],
    "answer": 4,
    "explanation": "교착 상태의 발생 조건은 상호 배제·점유와 대기·비선점·환형 대기 네 가지이며, 무한 루프는 로직 오류로 인한 현상입니다【736965116536844†L1-L3】."
  },
  {
    "number": 33,
    "question": "운영체제에서 다중 프로그래밍의 주요 목적은?",
    "options": [
      "보안 향상",
      "CPU 이용률 향상",
      "전력 절감",
      "에러 검출"
    ],
    "answer": 2,
    "explanation": "다중 프로그래밍은 여러 프로그램을 동시에 메모리에 유지함으로써 CPU의 이용률을 높이는 것을 주요 목적으로 합니다【751174799583755†L1-L2】."
  },
  {
    "number": 34,
    "question": "CPU가 여러 개의 프로세스를 번갈아가며 실행하는 방식은?",
    "options": [
      "다중 프로그래밍",
      "시분할 시스템",
      "일괄 처리 시스템",
      "실시간 시스템"
    ],
    "answer": 2,
    "explanation": "시분할 시스템은 CPU 시간을 짧은 간격으로 나누어 여러 프로세스가 번갈아 수행하게 하는 운영체제 방식입니다【779700311571655†L50-L52】."
  },
  {
    "number": 35,
    "question": "운영체제에서 문맥 교환(Context Switching)이 일어나는 시점은?",
    "options": [
      "데이터가 전송될 때",
      "프로세스가 종료될 때",
      "프로세스가 CPU를 양보할 때",
      "사용자가 프로그램을 실행할 때"
    ],
    "answer": 3,
    "explanation": "문맥 교환은 현재 실행 중인 프로세스가 CPU를 반납하고 다른 프로세스로 전환될 때 발생합니다【912534476933719†L3-L3】."
  },
  {
    "number": 36,
    "question": "운영체제에서 '프로세스'에 대한 설명으로 옳은 것은?",
    "options": [
      "컴파일된 프로그램 그 자체",
      "사용자의 명령어",
      "실행 중인 프로그램",
      "하드웨어 제어 장치"
    ],
    "answer": 3,
    "explanation": "프로세스는 실행 중인 프로그램과 관련 데이터, 할당된 자원을 포함하는 운영체제의 관리 단위입니다【736965116536844†L4-L4】."
  },
  {
    "number": 37,
    "question": "기억 장치의 계층 구조에서 가장 빠른 것은?",
    "options": [
      "레지스터",
      "캐시 메모리",
      "RAM",
      "하드디스크"
    ],
    "answer": 1,
    "explanation": "레지스터는 CPU 내부에 있는 저장 장치로, 캐시나 주기억장치보다도 빠르게 데이터를 읽고 쓸 수 있습니다【779700311571655†L61-L62】."
  },
  {
    "number": 38,
    "question": "정보보호의 3요소 중 기밀성(confidentiality)에 해당하는 것은?",
    "options": [
      "정보가 무단 변경되지 않도록 하는 것",
      "정보에 인가된 사용자만 접근 가능한 것",
      "정보를 언제든지 사용할 수 있는 것",
      "정보의 흐름을 제어하는 것"
    ],
    "answer": 2,
    "explanation": "기밀성은 권한이 있는 사용자만 정보에 접근할 수 있도록 하는 정보보호 원칙입니다【900043030509575†L1-L2】."
  },
  {
    "number": 39,
    "question": "다음 중 바이러스의 전파 매체로 볼 수 없는 것은?",
    "options": [
      "인터넷",
      "이메일",
      "USB",
      "키보드"
    ],
    "answer": 4,
    "explanation": "인터넷, 이메일, USB 저장장치는 바이러스 전파 경로가 될 수 있지만 키보드는 단순 입력 장치이므로 매체가 아닙니다【751174799583755†L3-L4】."
  },
  {
    "number": 40,
    "question": "보안 공격 중 사용자의 입력값을 조작하여 SQL 명령을 변경하는 기법은?",
    "options": [
      "DDoS",
      "XSS",
      "SQL Injection",
      "Phishing"
    ],
    "answer": 3,
    "explanation": "SQL Injection은 입력값에 악의적인 SQL 구문을 삽입하여 데이터베이스 쿼리를 조작하는 공격 기법입니다【779700311571655†L16-L18】."
  },
  {
    "number": 41,
    "question": "DBMS의 기능으로 적절하지 않은 것은?",
    "options": [
      "데이터 저장",
      "데이터 삭제",
      "데이터 암호화",
      "데이터 처리"
    ],
    "answer": 3,
    "explanation": "DBMS는 데이터 저장·검색·수정 등의 기능을 제공하지만, 데이터 암호화는 별도의 보안 모듈이나 암호화 소프트웨어가 수행하는 기능입니다【185763542736909†L1-L2】."
  },
  {
    "number": 42,
    "question": "정보보호 3요소에 해당하지 않는 것은?",
    "options": [
      "기밀성",
      "무결성",
      "가용성",
      "편의성"
    ],
    "answer": 4,
    "explanation": "정보보호의 기본 요소는 기밀성(confidentiality), 무결성(integrity), 가용성(availability)로 편의성은 포함되지 않습니다【360982841829634†L64-L65】."
  },
  {
    "number": 43,
    "question": "정보보호의 원칙 중 ‘권한 있는 사용자만 접근할 수 있어야 한다’는 무엇인가?",
    "options": [
      "기밀성",
      "무결성",
      "가용성",
      "신뢰성"
    ],
    "answer": 1,
    "explanation": "정보에 접근할 수 있는 권한을 제어하여 무단 접근을 막는 것을 기밀성이라고 합니다【900043030509575†L1-L2】."
  },
  {
    "number": 44,
    "question": "다음 중 네트워크 장비가 아닌 것은?",
    "options": [
      "라우터",
      "허브",
      "스위치",
      "마우스"
    ],
    "answer": 4,
    "explanation": "라우터·허브·스위치는 네트워크 연결 장치이며, 마우스는 컴퓨터 입력 장치로 네트워크 장비가 아닙니다【736965116536844†L3-L4】."
  },
  {
    "number": 45,
    "question": "LAN에서 충돌(Collision)을 감지하고 재전송하는 프로토콜은?",
    "options": [
      "CSMA/CD",
      "PPP",
      "HDLC",
      "SLIP"
    ],
    "answer": 1,
    "explanation": "CSMA/CD(Carrier Sense Multiple Access with Collision Detection)는 이더넷 LAN에서 신호 충돌을 감지하고 후 재전송하는 방법입니다【427048454652103†L3-L4】."
  },
  {
    "number": 46,
    "question": "다음 중 전송 오류를 검출하는 방식이 아닌 것은?",
    "options": [
      "패리티 검사",
      "CRC",
      "해밍 코드",
      "라우팅"
    ],
    "answer": 4,
    "explanation": "라우팅은 네트워크에서 데이터 전송 경로를 결정하는 기능으로 오류 검출 방식에 포함되지 않습니다【779700311571655†L54-L55】."
  },
  {
    "number": 47,
    "question": "OSI 7계층에서 ‘세션 계층’의 주요 역할은?",
    "options": [
      "논리적 주소 지정",
      "데이터 압축",
      "통신 세션의 설정·유지·종료",
      "물리적 연결"
    ],
    "answer": 3,
    "explanation": "세션 계층은 통신하는 두 시스템 사이의 세션을 설정하고 유지하며 종료하는 기능을 담당합니다【779700311571655†L54-L55】."
  },
  {
    "number": 48,
    "question": "IP 주소에서 클래스 A의 기본 서브넷 마스크는?",
    "options": [
      "255.255.255.0",
      "255.255.0.0",
      "255.0.0.0",
      "255.255.255.255"
    ],
    "answer": 3,
    "explanation": "클래스 A 주소는 첫 8비트가 네트워크 부분이므로 기본 서브넷 마스크는 255.0.0.0입니다【900043030509575†L2-L3】."
  },
  {
    "number": 49,
    "question": "TCP/IP 계층 중 데이터의 경로를 결정하는 계층은?",
    "options": [
      "응용 계층",
      "전송 계층",
      "인터넷 계층",
      "네트워크 접근 계층"
    ],
    "answer": 3,
    "explanation": "인터넷 계층(IP 계층)은 IP 주소를 이용하여 패킷을 목적지까지 전달할 경로를 결정합니다【900043030509575†L3-L4】."
  },
  {
    "number": 50,
    "question": "OSI 7계층 중 물리적인 전송 매체를 다루는 계층은?",
    "options": [
      "응용 계층",
      "전송 계층",
      "네트워크 계층",
      "물리 계층"
    ],
    "answer": 4,
    "explanation": "물리 계층은 전기적 신호, 케이블, 커넥터 등 실제 전송 매체를 처리하는 계층입니다【736965116536844†L3-L4】."
  },
  {
    "number": 51,
    "question": "OSI 7계층 중 전송 계층(Transport Layer)의 주요 기능은?",
    "options": [
      "라우팅",
      "데이터 암호화",
      "종단 간 연결 제공",
      "물리적 전송"
    ],
    "answer": 3,
    "explanation": "전송 계층은 송수신 프로세스 간 신뢰성 있는 데이터 전송을 보장하는 종단 간 연결을 제공합니다【677880205694508†L140-L144】."
  },
  {
    "number": 52,
    "question": "응용 계층(Application Layer)의 대표적인 프로토콜은?",
    "options": [
      "TCP",
      "IP",
      "HTTP",
      "UDP"
    ],
    "answer": 3,
    "explanation": "HTTP는 웹 브라우저와 서버 사이의 통신을 담당하는 응용 계층 프로토콜입니다【185763542736909†L1-L3】."
  },
  {
    "number": 53,
    "question": "UDP 프로토콜의 특징은?",
    "options": [
      "신뢰성 보장",
      "연결 지향",
      "오버헤드 적음",
      "흐름 제어 있음"
    ],
    "answer": 3,
    "explanation": "UDP는 비연결형 프로토콜로 오류 검출이나 흐름 제어를 거의 수행하지 않기 때문에 오버헤드가 적습니다【677880205694508†L134-L138】."
  },
  {
    "number": 1,
    "question": "어떤 정규형은 비정규화 관계에서 생길 수 있는 이행적 종속성을 제거하는 데 중점을 둡니까?",
    "options": [
      "제1정규형(1NF)",
      "제2정규형(2NF)",
      "제3정규형(3NF)",
      "제4정규형(4NF)"
    ],
    "answer": 3,
    "explanation": "제3정규형은 비주요 속성이 기본키가 아닌 다른 비주요 속성에 종속되는 이행적 종속을 제거하도록 요구한다【913125625040050†L124-L133】. 따라서 제3정규형에 맞추면 속성들은 기본키에만 종속되고 이행적 종속이 제거된다."
  },
  {
    "number": 2,
    "question": "관계에 존재하는 모든 함수 종속의 좌변이 슈퍼키가 되도록 요구하는 정규형은 무엇입니까?",
    "options": [
      "제3정규형(3NF)",
      "제4정규형(4NF)",
      "보이스ㆍ코드 정규형(BCNF)",
      "제5정규형(5NF)"
    ],
    "answer": 3,
    "explanation": "BCNF는 테이블의 모든 결정자가 슈퍼키(superkey)여야 한다고 규정한다【913125625040050†L135-L144】. 이는 각 함수 종속의 좌변이 후보키 또는 슈퍼키임을 요구한다."
  },
  {
    "number": 3,
    "question": "어떤 정규형은 한 관계에서 다치 종속(MVD)을 허용하지 않도록 하여 하나의 속성이 다른 속성 집합에 독립적으로 여러 값을 갖지 못하게 합니까?",
    "options": [
      "제1정규형(1NF)",
      "제3정규형(3NF)",
      "제4정규형(4NF)",
      "제5정규형(5NF)"
    ],
    "answer": 3,
    "explanation": "제4정규형은 한 관계에서 다치 종속이 발생하지 않도록 요구한다. 즉, 어떤 속성 집합이 다른 속성 집합에 독립적으로 여러 값을 갖는 상황을 제거한다【913125625040050†L145-L153】."
  },
  {
    "number": 4,
    "question": "어떤 정규형은 조인 종속을 제거하여 관계를 더 이상 손실 없이 분해할 수 없는 형태로 만드는 것을 목표로 합니까?",
    "options": [
      "제2정규형(2NF)",
      "제3정규형(3NF)",
      "제4정규형(4NF)",
      "제5정규형(5NF)"
    ],
    "answer": 4,
    "explanation": "제5정규형은 관계를 조인 종속에 의해 추가로 분해할 필요가 없는 상태로 만드는 정규형으로, 관계가 모든 조인 종속을 만족하면서도 더 이상 손실 없이 분해할 수 없는 경우를 의미한다【913125625040050†L156-L160】."
  },
  {
    "number": 5,
    "question": "트랜잭션 간 병행 수행에서 한 트랜잭션이 아직 확정(commit)되지 않은 다른 트랜잭션의 데이터를 읽는 문제는 무엇입니까?",
    "options": [
      "더티 리드(temporary update problem)",
      "잃어버린 업데이트 문제(lost update)",
      "반복 불가능한 읽기 문제(unrepeatable read)",
      "팬텀 리드(phantom read)"
    ],
    "answer": 1,
    "explanation": "다른 트랜잭션이 변경한 데이터를 아직 커밋 전에 읽는 상황은 더티 리드(또는 임시 업데이트 문제)라고 하며, 이는 트랜잭션 간의 병행성 문제 중 하나이다【332167302310236†L91-L154】."
  },
  {
    "number": 6,
    "question": "두 트랜잭션이 같은 데이터를 업데이트할 때 한 트랜잭션의 업데이트가 다른 트랜잭션의 업데이트에 의해 덮여 버리는 병행성 문제는 무엇입니까?",
    "options": [
      "더티 리드", "잃어버린 업데이트", "반복 불가능한 읽기", "팬텀 리드"
    ],
    "answer": 2,
    "explanation": "두 트랜잭션이 같은 데이터를 수정하면서 하나의 트랜잭션이 다른 트랜잭션의 업데이트를 덮어쓰는 상황은 잃어버린 업데이트 문제라고 한다【332167302310236†L91-L154】."
  },
  {
    "number": 7,
    "question": "같은 트랜잭션이 동일한 행을 두 번 읽을 때, 다른 트랜잭션의 업데이트로 인해 두 번째 읽기에서 다른 값을 얻는 병행성 문제는 무엇입니까?",
    "options": [
      "더티 리드", "잃어버린 업데이트", "반복 불가능한 읽기", "팬텀 리드"
    ],
    "answer": 3,
    "explanation": "한 트랜잭션이 같은 행을 두 번 읽는데 그 사이에 다른 트랜잭션이 데이터를 변경하여 값이 달라지는 문제를 반복 불가능한 읽기(unrepeatable read)라고 한다【332167302310236†L91-L154】."
  },
  {
    "number": 8,
    "question": "쿼리를 다시 실행할 때 다른 트랜잭션이 추가한 새로운 행이 결과에 나타나는 병행성 문제를 무엇이라고 합니까?",
    "options": [
      "더티 리드", "잃어버린 업데이트", "반복 불가능한 읽기", "팬텀 리드"
    ],
    "answer": 4,
    "explanation": "처음 조회 시 없던 행이 다른 트랜잭션에 의해 삽입되어 재조회 시 결과에 나타나는 현상은 팬텀 리드라고 한다【332167302310236†L91-L154】."
  },
  {
    "number": 9,
    "question": "계층형 데이터베이스 모델의 주요 특징은 무엇입니까?",
    "options": [
      "레코드 간 많은-to-많은 관계를 허용한다",
      "부모-자식 트리 구조로 각 부모가 여러 자식을 가질 수 있다",
      "키-값 쌍으로 데이터를 저장한다",
      "객체와 상속을 사용하여 데이터를 표현한다"
    ],
    "answer": 2,
    "explanation": "계층형 데이터베이스는 데이터를 부모-자식 관계의 트리 구조로 저장하며 하나의 부모가 여러 자식을 가질 수 있다【691336932829712†L100-L114】."
  },
  {
    "number": 10,
    "question": "네트워크 데이터베이스 모델이 다른 모델과 차별화되는 특징은 무엇입니까?",
    "options": [
      "레코드 간 일대일 관계만 허용한다",
      "하나의 레코드가 여러 부모와 많은 자식 간의 많은-to-많은 관계를 허용한다",
      "테이블 간 정규화를 지원한다",
      "객체와 메시지를 사용한다"
    ],
    "answer": 2,
    "explanation": "네트워크 데이터베이스 모델은 레코드들이 그래프 형태로 연결되어 한 레코드가 여러 부모를 가질 수 있으며 많은-to-많은 관계를 지원한다【691336932829712†L130-L142】."
  },
  {
    "number": 11,
    "question": "INSERT, UPDATE, DELETE 같은 이벤트가 발생할 때 자동으로 실행되어 데이터 무결성을 보장하는 SQL 객체는 무엇입니까?",
    "options": [
      "뷰(View)", "인덱스(Index)", "트리거(Trigger)", "커서(Cursor)"
    ],
    "answer": 3,
    "explanation": "트리거는 특정 테이블에서 INSERT, UPDATE, DELETE 등이 수행될 때 자동으로 실행되는 저장된 프로시저로, 데이터 무결성과 비즈니스 규칙을 enforced 한다【415323756129203†L63-L105】."
  },
  {
    "number": 12,
    "question": "트리거에 대한 설명 중 옳지 않은 것은 무엇입니까?",
    "options": [
      "데이터 무결성 유지에 사용될 수 있다",
      "INSERT나 DELETE 등의 이벤트 이전 또는 이후에 실행될 수 있다",
      "사용자가 명시적으로 호출해야만 실행된다",
      "행 수준 또는 문장 수준으로 정의할 수 있다"
    ],
    "answer": 3,
    "explanation": "트리거는 DML 이벤트가 발생하면 자동으로 실행되므로 사용자가 명시적으로 호출할 필요가 없다【415323756129203†L63-L105】."
  },
  {
    "number": 13,
    "question": "CREATE, ALTER, DROP 등의 명령으로 데이터베이스 구조를 정의하는 SQL 명령 종류는 무엇입니까?",
    "options": [
      "데이터 정의 언어(DDL)", "데이터 조작 언어(DML)", "데이터 제어 언어(DCL)", "트랜잭션 제어 언어(TCL)"
    ],
    "answer": 1,
    "explanation": "DDL은 CREATE, ALTER, DROP과 같이 데이터베이스의 테이블, 스키마 등을 정의하거나 변경하는 명령을 제공한다【634635959219113†L65-L120】."
  },
  {
    "number": 14,
    "question": "INSERT, UPDATE, DELETE, SELECT 명령과 같이 데이터 조작을 위한 SQL 명령들은 무엇으로 분류됩니까?",
    "options": [
      "DDL", "DML", "DCL", "TCL"
    ],
    "answer": 2,
    "explanation": "데이터 조작 언어(DML)는 데이터의 삽입, 수정, 삭제, 조회를 위한 명령들을 포함하며, 명령 실행 결과는 트랜잭션으로 취소할 수 있다【634635959219113†L65-L120】."
  },
  {
    "number": 15,
    "question": "저장 프로시저와 사용자 정의 함수에 대한 설명 중 옳은 것은 무엇입니까?",
    "options": [
      "함수는 SELECT 문에서 사용할 수 없다",
      "저장 프로시저는 반드시 반환값을 가져야 한다",
      "함수는 반드시 값을 반환해야 한다",
      "저장 프로시저는 함수 내부에서 호출될 수 있지만 반대는 불가능하다"
    ],
    "answer": 3,
    "explanation": "사용자 정의 함수는 반드시 단일 값을 반환하며 SELECT 문에서 사용할 수 있는 반면, 저장 프로시저는 반환값이 optional이고 주로 실행을 위한 절차식 코드이다【742370801914452†L70-L169】."
  },
  {
    "number": 16,
    "question": "범위 질의를 효율적으로 처리하고 동적 삽입ㆍ삭제에 적합하며 균형 트리 구조로 구현되는 인덱싱 기법은 무엇입니까?",
    "options": [
      "해시 인덱스(Hash index)", "B-트리 인덱스", "비트맵 인덱스", "LRU 캐시"
    ],
    "answer": 2,
    "explanation": "B-트리 인덱스는 균형 잡힌 트리 구조를 사용하므로 범위 검색에 적합하며 노드 삽입과 삭제가 동적으로 이루어진다【241182811143001†L73-L90】."
  },
  {
    "number": 17,
    "question": "정확한 값 검색에 상수 시간 성능을 제공하지만 범위 검색에는 적합하지 않은 인덱싱 기법은 무엇입니까?",
    "options": [
      "트라이 인덱스", "B-트리 인덱스", "해시 인덱스", "역방향 인덱스"
    ],
    "answer": 3,
    "explanation": "해시 인덱스는 해시 함수를 이용해 키를 버킷으로 매핑하므로 정확한 값 검색에서는 O(1) 성능을 제공하지만 순서와 범위 정보를 유지하지 않아 범위 검색에는 적합하지 않다【241182811143001†L102-L123】."
  },
  {
    "number": 18,
    "question": "ACID 속성 중 ‘트랜잭션이 커밋된 후에는 시스템 장애가 발생하더라도 완료된 작업 결과는 유지되어야 한다’는 성질은 무엇입니까?",
    "options": [
      "원자성(Atomicity)", "일관성(Consistency)", "격리성(Isolation)", "지속성(Durability)"
    ],
    "answer": 4,
    "explanation": "지속성은 트랜잭션이 commit된 후 그 결과가 비휘발성 메모리에 기록되어 시스템 고장이 발생해도 유지되어야 함을 의미한다【574985405674053†L261-L264】."
  },
  {
    "number": 19,
    "question": "테이블의 각 행을 고유하게 식별하며 NULL 값을 가질 수 없는 속성 집합을 무엇이라고 합니까?",
    "options": [
      "외래 키", "대체 키", "기본 키", "복합 키"
    ],
    "answer": 3,
    "explanation": "기본 키는 각 튜플을 유일하게 식별하기 위한 속성 또는 속성 집합으로, NULL 값을 포함할 수 없다【233473295392333†L65-L81】."
  },
  {
    "number": 20,
    "question": "한 트랜잭션이 SUM이나 COUNT와 같이 집계 함수를 수행하는 동안 다른 트랜잭션이 관련 데이터를 변경하여 잘못된 요약 결과를 초래하는 병행성 문제는 무엇입니까?",
    "options": [
      "더티 리드", "잃어버린 업데이트", "반복 불가능한 읽기", "잘못된 요약 문제(incorrect summary)"
    ],
    "answer": 4,
    "explanation": "집계 함수를 수행하는 동안 다른 트랜잭션이 데이터를 변경하여 결과가 일관되지 않게 되는 경우를 잘못된 요약 문제라 한다【332167302310236†L91-L154】."
  },
  {
    "number": 21,
    "question": "선형적이고 순차적인 단계(요구 분석→설계→구현→테스트→배포→유지보수)를 따르는 소프트웨어 개발 생명주기 모델은 무엇입니까?",
    "options": [
      "워터폴 모델", "애자일 모델", "스파이럴 모델", "프로토타입 모델"
    ],
    "answer": 1,
    "explanation": "워터폴 모델은 각 단계가 완전히 끝난 후 다음 단계로 넘어가는 직선적·순차적 접근을 취하는 전통적인 소프트웨어 개발 모델이다【679206755465578†L66-L72】."
  },
  {
    "number": 22,
    "question": "워터폴 모델의 첫 번째 단계로, 사용자 요구사항을 수집하고 명세서를 작성하는 과정은 무엇입니까?",
    "options": [
      "요구 사항 분석/명세 단계", "설계 단계", "테스트 단계", "유지보수 단계"
    ],
    "answer": 1,
    "explanation": "워터폴 모델에서 요구 사항 분석/명세 단계는 시스템에 필요한 기능과 제약사항을 파악하여 문서화하는 초기 단계다【679206755465578†L100-L134】."
  },
  {
    "number": 23,
    "question": "워터폴 모델에서 전체 시스템 구조와 모듈화, 데이터 설계를 정의하는 단계는 무엇입니까?",
    "options": [
      "요구 분석", "설계 단계", "테스트 단계", "배포 단계"
    ],
    "answer": 2,
    "explanation": "설계 단계에서는 요구 분석 결과를 바탕으로 고수준 설계(HLD)와 상세 설계(LLD)를 작성하여 시스템 구조와 모듈, 데이터 흐름 등을 정의한다【679206755465578†L100-L134】."
  },
  {
    "number": 24,
    "question": "소프트웨어 모듈 간 상호 의존성의 정도를 나타내며, 낮을수록 바람직한 이 특성을 무엇이라 합니까?",
    "options": [
      "응집도(Cohesion)", "결합도(Coupling)", "캡슐화", "추상화"
    ],
    "answer": 2,
    "explanation": "결합도는 모듈 간의 상호 의존성을 의미하며, 결합도가 낮을수록 모듈간 영향을 줄이고 재사용성이 높아진다【951453904116397†L86-L97】."
  },
  {
    "number": 25,
    "question": "모듈 내부 요소들이 하나의 목적을 위해 얼마나 밀접하게 연관되어 있는지를 나타내며 높을수록 바람직한 이 특성은 무엇입니까?",
    "options": [
      "응집도(Cohesion)", "결합도(Coupling)", "상속성", "다형성"
    ],
    "answer": 1,
    "explanation": "응집도는 모듈 내부의 요소들이 같은 기능을 수행하는 정도를 나타내며, 응집도가 높을수록 모듈은 잘 정의된 단일 책임을 수행한다【951453904116397†L86-L97】."
  },
  {
    "number": 26,
    "question": "소프트웨어의 개별 모듈 또는 구성 요소를 독립적으로 검증하여 올바르게 동작하는지 확인하는 테스트 종류는 무엇입니까?",
    "options": [
      "단위 테스트(Unit Testing)", "통합 테스트(Integration Testing)", "시스템 테스트(System Testing)", "인수 테스트(Acceptance Testing)"
    ],
    "answer": 1,
    "explanation": "단위 테스트는 프로그램의 가장 작은 단위(함수, 메서드 등)를 분리해 테스트하는 것으로 코드 조각이 기대한 대로 작동하는지 검증한다【698347577395047†L498-L500】."
  },
  {
    "number": 27,
    "question": "개별 모듈을 결합하여 모듈 간 인터페이스와 상호 작용을 검사하는 소프트웨어 테스트는 무엇입니까?",
    "options": [
      "단위 테스트", "통합 테스트", "시스템 테스트", "인수 테스트"
    ],
    "answer": 2,
    "explanation": "통합 테스트는 여러 단위가 합쳐져 상호 작용할 때 오류가 없는지 확인하는 과정이다【698347577395047†L508-L512】."
  },
  {
    "number": 28,
    "question": "완성된 소프트웨어 시스템 전체를 대상 영역에 따라 검증하는 테스트로, 요구사항에 맞게 동작하는지 평가하는 것은 무엇입니까?",
    "options": [
      "단위 테스트", "통합 테스트", "시스템 테스트", "회귀 테스트"
    ],
    "answer": 3,
    "explanation": "시스템 테스트는 완성된 소프트웨어 시스템을 사용자 요구사항 및 규격에 맞추어 전체적으로 평가하는 단계이다【698347577395047†L520-L522】."
  },
  {
    "number": 29,
    "question": "고객이나 최종 사용자가 실제로 제품을 사용해보며 요구사항을 충족하는지 판단하는 테스트는 무엇입니까?",
    "options": [
      "단위 테스트", "시스템 테스트", "인수 테스트", "회귀 테스트"
    ],
    "answer": 3,
    "explanation": "인수 테스트는 시스템이 고객의 요구사항과 기대에 부합하는지 확인하기 위해 사용자가 실행하는 테스트이다【698347577395047†L836-L839】."
  },
  {
    "number": 30,
    "question": "소프트웨어의 특정 기능이나 동작이 요구사항을 충족하는지 검증하는 테스트로, 시스템이 해야 할 일을 확인하는 것은 무엇입니까?",
    "options": [
      "기능 테스트(Function Testing)", "비기능 테스트(Non-functional Testing)", "스트레스 테스트", "정적 테스트"
    ],
    "answer": 1,
    "explanation": "기능 테스트는 소프트웨어의 각 기능이 명세된 요구사항에 따라 올바르게 작동하는지 확인하는 테스트이다【698347577395047†L904-L917】."
  },
  {
    "number": 31,
    "question": "성능, 신뢰성, 보안 등과 같이 기능 외적인 품질 속성을 검증하는 테스트는 무엇입니까?",
    "options": [
      "기능 테스트", "단위 테스트", "비기능 테스트", "베타 테스트"
    ],
    "answer": 3,
    "explanation": "비기능 테스트는 시스템의 성능, 확장성, 보안, 사용자 경험 등 기능 이외의 요구사항을 평가한다【698347577395047†L904-L917】."
  },
  {
    "number": 32,
    "question": "코드의 내부 구조와 로직을 고려하여 실행 경로를 시험하는 테스트 기법은 무엇입니까?",
    "options": [
      "블랙박스 테스트", "화이트박스 테스트", "사용성 테스트", "정적 분석"
    ],
    "answer": 2,
    "explanation": "화이트박스 테스트(구조 테스트)는 소스 코드의 내부 구조와 제어 흐름을 이해하고, 분기와 경로를 테스트한다【698347577395047†L592-L604】."
  },
  {
    "number": 33,
    "question": "시스템이 예상되는 부하 하에서 얼마나 잘 동작하는지 확인하기 위해 수행하는 성능 테스트는 무엇입니까?",
    "options": [
      "부하 테스트(Load Testing)", "스트레스 테스트(Stress Testing)", "사용성 테스트", "안정성 테스트"
    ],
    "answer": 1,
    "explanation": "부하 테스트는 시스템이 정상 범위의 사용자 수나 거래량 등 예상 부하 조건에서 요구된 성능을 충족하는지 평가한다【698347577395047†L956-L969】."
  },
  {
    "number": 34,
    "question": "시스템을 한계 이상으로 몰아가 극한 조건에서도 안정적으로 동작하는지 검증하는 테스트는 무엇입니까?",
    "options": [
      "부하 테스트", "스트레스 테스트", "단위 테스트", "통합 테스트"
    ],
    "answer": 2,
    "explanation": "스트레스 테스트는 시스템에 과도한 부하를 가해 예기치 않은 조건에서의 안정성과 오류 처리를 확인한다【698347577395047†L956-L969】."
  },
  {
    "number": 35,
    "question": "실제 사용자가 시스템을 사용하며 인터페이스의 편의성과 직관성을 평가하는 테스트는 무엇입니까?",
    "options": [
      "성능 테스트", "사용성 테스트", "통합 테스트", "인수 테스트"
    ],
    "answer": 2,
    "explanation": "사용성 테스트는 사용자가 제품을 실제로 사용해보면서 인터페이스가 편리하고 이해하기 쉬운지 평가하는 테스트이다【698347577395047†L984-L986】."
  },
  {
    "number": 36,
    "question": "운영 환경에서 소프트웨어가 배포될 준비가 되었는지, 인프라와 프로세스에 적합한지 검증하는 테스트는 무엇입니까?",
    "options": [
      "인수 테스트", "운영 수용 테스트(OAT)", "베타 테스트", "알파 테스트"
    ],
    "answer": 2,
    "explanation": "운영 수용 테스트(OAT)는 시스템이 실제 운영 환경에서 배포될 준비가 되었는지, 백업, 복구, 보안 등 비기능적인 요구사항을 만족하는지 평가한다【698347577395047†L854-L860】."
  },
  {
    "number": 37,
    "question": "코드를 실행하지 않고 문서, 설계, 요구사항을 검토하거나 분석하여 결함을 찾아내는 테스트 기법은 무엇입니까?",
    "options": [
      "정적 테스트", "동적 테스트", "블랙박스 테스트", "베타 테스트"
    ],
    "answer": 1,
    "explanation": "정적 테스트는 프로그램을 실행하지 않고 코드, 설계 문서를 검토해 결함이나 편차를 발견하는 방법이다【698347577395047†L527-L537】."
  },
  {
    "number": 38,
    "question": "프로젝트를 여러 독립적인 구성요소로 분할하여 병렬로 개발하고, 각 요소를 테스트 시점에 통합하는 개발 방식은 무엇입니까?",
    "options": [
      "단계적 모델", "단순 반복적 개발", "폭포수 모델", "대규모 계단식 모델"
    ],
    "answer": 2,
    "explanation": "단순 반복적 개발에서는 시스템을 작은 컴포넌트로 나누어 병렬로 개발하고, 마이크로서비스 기반 설계를 통해 각 부분을 통합하여 테스트한다【234098485594540†L114-L130】."
  },
  {
    "number": 39,
    "question": "변화 요청이 있을 때마다 짧은 스프린트를 통해 설계-코딩-테스트-배포를 반복하는 개발 방법론은 무엇입니까?",
    "options": [
      "폭포수 모델", "애자일 개발", "프로토타이핑 모델", "대규모 계단식 모델"
    ],
    "answer": 2,
    "explanation": "애자일 개발은 반복적 개발에 기반하여 스프린트라 불리는 짧은 기간 동안 요구사항을 반영한 설계, 구현, 테스트를 수행하며 변화에 빠르게 대응한다【234098485594540†L139-L156】."
  },
  {
    "number": 40,
    "question": "서로 독립적인 기능이 많고 잦은 변경이 요구되는 프로젝트는 어떤 개발 방법론이 적합하다고 언급됩니까?",
    "options": [
      "폭포수 모델", "애자일 방법론", "스파이럴 모델", "간트 차트 모델"
    ],
    "answer": 2,
    "explanation": "기능 간 결합도가 낮고 빈번한 변경이 필요한 경우, 변화에 유연하게 대응할 수 있는 애자일 방법론이 적합하다【234098485594540†L169-L184】."
  },
  {
    "number": 41,
    "question": "운영체제의 CPU 스케줄링에서 실행 중인 프로세스를 다른 프로세스로 교체할 수 있도록 하는 스케줄링 방식은 무엇입니까?",
    "options": [
      "선점형 스케줄링", "비선점형 스케줄링", "우선순위 스케줄링", "라운드 로빈 스케줄링"
    ],
    "answer": 1,
    "explanation": "선점형 스케줄링에서는 실행 중인 프로세스라도 타 프로세스에게 CPU를 양도하도록 강제로 중단시킬 수 있다【929917391492618†L223-L227】."
  },
  {
    "number": 42,
    "question": "비선점형 스케줄링에서는 실행 중인 프로세스가 어떤 경우에만 CPU를 반환합니까?",
    "options": [
      "타임 퀀텀이 끝날 때", "높은 우선순위의 프로세스가 도착할 때", "프로세스가 완료되거나 기다림 상태로 전환될 때", "I/O 인터럽트가 발생할 때마다"
    ],
    "answer": 3,
    "explanation": "비선점형 스케줄링에서는 실행 중인 프로세스가 종료되거나 I/O 요청 등으로 대기 상태로 전환될 때만 CPU를 내어준다【929917391492618†L220-L223】."
  },
  {
    "number": 43,
    "question": "프로세스들이 실행을 기다리기 위해 메모리에 유지되는 큐는 무엇이라고 합니까?",
    "options": [
      "준비 큐(ready queue)", "작업 큐(job queue)", "장치 큐(device queue)", "대기 큐(wait queue)"
    ],
    "answer": 1,
    "explanation": "준비 큐는 메모리에 적재된 후 실행을 기다리고 있는 모든 프로세스들을 관리하는 큐이다【929917391492618†L240-L246】."
  },
  {
    "number": 44,
    "question": "시스템에 있는 프로세스 중 어느 프로세스를 메모리에 가져와 실행 대기 상태에 둘지 결정하여 다중 프로그래밍 정도를 제어하는 스케줄러는 무엇입니까?",
    "options": [
      "장기 스케줄러", "단기 스케줄러", "중기 스케줄러", "컨텍스트 스케줄러"
    ],
    "answer": 1,
    "explanation": "장기 스케줄러는 디스크의 작업 큐에 있는 프로세스들 중 일부를 메모리에 적재하여 준비 큐로 옮겨 다중 프로그래밍의 정도를 조절한다【929917391492618†L289-L299】."
  },
  {
    "number": 45,
    "question": "준비 큐에서 실행할 프로세스를 선택해 CPU를 배정하는 역할을 하며 가장 빠른 빈도로 동작하는 스케줄러는 무엇입니까?",
    "options": [
      "장기 스케줄러", "단기 스케줄러", "중기 스케줄러", "후기 스케줄러"
    ],
    "answer": 2,
    "explanation": "단기 스케줄러(CPU 스케줄러)는 준비 큐에서 다음에 실행할 프로세스를 선택해 CPU를 할당하며 가장 자주 실행된다【929917391492618†L306-L315】."
  },
  {
    "number": 46,
    "question": "다중 프로그래밍의 정도를 줄이기 위해 프로세스를 일시적으로 메모리에서 제거하거나 다시 불러오는 스케줄러는 무엇입니까?",
    "options": [
      "장기 스케줄러", "단기 스케줄러", "중기 스케줄러", "실시간 스케줄러"
    ],
    "answer": 3,
    "explanation": "중기 스케줄러는 프로세스를 디스크로 스왑 아웃했다가 이후 다시 메모리로 스왑 인하여 메모리 사용량과 다중 프로그래밍 정도를 조절한다【929917391492618†L317-L321】."
  },
  {
    "number": 47,
    "question": "프로세스를 전환할 때 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하는 과정을 무엇이라고 합니까?",
    "options": [
      "컨텍스트 스위칭", "페이지 교체", "스케줄링", "캐시 플러시"
    ],
    "answer": 1,
    "explanation": "컨텍스트 스위칭은 실행 중인 프로세스의 레지스터와 프로그램 카운터 등을 저장하고 다음 프로세스의 상태를 복원하여 다중작업을 가능하게 하는 과정이다【929917391492618†L347-L357】."
  },
  {
    "number": 48,
    "question": "고정된 크기의 페이지 단위로 메모리를 나누어 외부 단편화를 없애고 프로그래머에게 투명하게 동작하는 기법은 무엇입니까?",
    "options": [
      "세그멘테이션(segmentation)", "페이징(paging)", "동적 분할", "스와핑(swapping)"
    ],
    "answer": 2,
    "explanation": "페이징 기법은 동일한 크기의 페이지와 프레임으로 메모리를 나누어 프로그램이 연속된 공간에 적재될 필요가 없게 하며 외부 단편화를 제거한다【989012850508958†L69-L75】【989012850508958†L137-L142】."
  },
  {
    "number": 49,
    "question": "가상 메모리의 페이지와 실제 메모리의 프레임에 대한 설명으로 맞는 것은?",
    "options": [
      "페이지는 물리 메모리의 블록이고 프레임은 가상 주소 공간의 블록이다",
      "페이지는 가상 메모리의 고정 크기 블록이며, 프레임은 동일 크기의 물리 메모리 블록이다",
      "페이지는 가변 크기이고 프레임은 고정 크기이다",
      "페이지와 프레임은 무관하며 크기가 다를 수 있다"
    ],
    "answer": 2,
    "explanation": "페이징에서 페이지는 가상 주소 공간의 동일한 크기의 블록이고, 프레임은 물리 메모리에 있는 동일한 크기의 블록이다【989012850508958†L91-L94】."
  },
  {
    "number": 50,
    "question": "논리적 단위(함수, 배열 등)에 따라 메모리를 가변 크기의 세그먼트로 나누며 외부 단편화가 발생할 수 있는 기법은 무엇입니까?",
    "options": [
      "페이징", "세그멘테이션", "캐싱", "메모리 풀링"
    ],
    "answer": 2,
    "explanation": "세그멘테이션은 사용자가 정의한 논리 단위별로 가변 크기 세그먼트를 할당하므로 외부 단편화가 발생할 수 있다【989012850508958†L69-L75】."
  },
  {
    "number": 51,
    "question": "페이징 시스템에서 최근 사용한 페이지 테이블 항목을 캐시에 저장해 주소 변환을 가속화하는 하드웨어는 무엇입니까?",
    "options": [
      "캐시 메모리", "변환 변환 버퍼(TLB)", "세그먼트 레지스터", "디스크 버퍼"
    ],
    "answer": 2,
    "explanation": "TLB(Translation Lookaside Buffer)는 최근 참조된 페이지 테이블 항목을 저장해 주소 변환 속도를 향상시키는 캐시 역할을 한다【989012850508958†L121-L124】."
  },
  {
    "number": 52,
    "question": "세그멘테이션에서는 가변 크기의 세그먼트 할당 때문에 발생할 수 있는 메모리 낭비는 어떤 단편화에 해당합니까?",
    "options": [
      "내부 단편화", "외부 단편화", "시간 단편화", "페이지 폴트"
    ],
    "answer": 2,
    "explanation": "세그멘테이션은 가변 크기의 세그먼트를 사용하므로 세그먼트 사이에 사용되지 않는 작은 공간(외부 단편화)이 발생할 수 있다【989012850508958†L137-L142】."
  },
  {
    "number": 53,
    "question": "다음 중 세그멘테이션에 대한 설명으로 옳은 것은?",
    "options": [
      "세그먼트는 고정 크기이며 프로그래머에게 보이지 않는다",
      "세그먼트는 함수나 배열과 같은 논리적 단위에 대응한다",
      "세그멘테이션은 외부 단편화를 완전히 제거한다",
      "세그멘테이션은 페이징보다 항상 효율적이다"
    ],
    "answer": 2,
    "explanation": "세그멘테이션에서 세그먼트는 프로그램의 함수, 배열 등 논리적 단위에 대응하며, 각 세그먼트는 가변 크기이다【989012850508958†L69-L75】."
  },
  {
    "number": 54,
    "question": "운영체제에서 교착 상태(deadlock)가 발생하기 위해서는 네 가지 조건이 동시에 만족해야 한다. 다음 중 해당 조건이 아닌 것은?",
    "options": [
      "상호 배제", "보유 및 대기", "비선점", "비순환 대기 조건이 없다"
    ],
    "answer": 4,
    "explanation": "교착 상태가 발생하려면 상호 배제, 보유 및 대기, 비선점, 순환 대기 네 가지 조건이 모두 성립해야 한다. 비순환 대기 조건이 없다는 것은 교착 상태 조건에 해당하지 않는다【220281651101113†L130-L200】."
  },
  {
    "number": 55,
    "question": "교착 상태 발생 조건 중 \"프로세스가 이미 보유한 자원을 방출하지 않은 채 다른 자원을 기다린다\"는 어떤 조건입니까?",
    "options": [
      "상호 배제", "보유 및 대기", "비선점", "순환 대기"
    ],
    "answer": 2,
    "explanation": "보유 및 대기 조건은 프로세스가 하나 이상의 자원을 보유한 상태로 추가 자원을 요청하며 해당 자원이 할당될 때까지 기다리는 상황을 의미한다【220281651101113†L141-L150】."
  },
  {
    "number": 56,
    "question": "프로세스들이 서로 피해 없이 계속 상태를 바꾸고 있지만 실제로 아무 작업도 진행되지 않는 상황을 무엇이라고 합니까?",
    "options": [
      "교착 상태", "라이브락(livelock)", "스레드", "선점형 스케줄링"
    ],
    "answer": 2,
    "explanation": "라이브락은 프로세스들이 교착 상태를 피하기 위해 서로 상태를 바꾸기만 하고 실제로는 전혀 진행되지 않는 상황을 말한다【220281651101113†L166-L178】."
  },
  {
    "number": 57,
    "question": "고정 길이의 시간 할당량을 사용하여 각 프로세스에게 CPU를 순차적으로 배정하는 공정하고 기아가 없는 스케줄링 알고리즘은 무엇입니까?",
    "options": [
      "선입선출(FCFS)", "최단 작업 우선(SJF)", "라운드 로빈", "우선순위 스케줄링"
    ],
    "answer": 3,
    "explanation": "라운드 로빈 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 주어 순환하면서 CPU를 배정하므로 간단하고 기아 현상이 없다【910792925568279†L146-L152】【910792925568279†L162-L170】."
  },
  {
    "number": 58,
    "question": "스레드에 대한 설명으로 옳은 것은 무엇입니까?",
    "options": [
      "독립적인 프로그램이며 자체 메모리 공간을 가진다", "스케줄러가 독립적으로 관리하는 명령의 가장 작은 단위이다", "하나의 프로세스는 하나의 스레드만 가질 수 있다", "스레드는 프로세스 간 메모리를 공유하지 않는다"
    ],
    "answer": 2,
    "explanation": "스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위로, 스케줄러가 관리하며 같은 프로세스의 다른 스레드와 메모리와 자원을 공유한다【510674314705443†L188-L198】."
  },
  {
    "number": 59,
    "question": "같은 프로세스 내의 스레드들이 공유하는 자원으로 알맞은 것은?",
    "options": [
      "고유한 주소 공간", "서로 다른 파일 디스크립터", "프로세스의 메모리 및 자원", "독립적인 PCB(Process Control Block)"
    ],
    "answer": 3,
    "explanation": "스레드는 같은 프로세스의 코드, 데이터, 열린 파일과 같은 자원을 공유한다. 각각의 스레드는 스케줄링 정보 등 최소한의 상태만 별도로 가진다【510674314705443†L188-L198】."
  },
  {
    "number": 60,
    "question": "다중 프로그래밍 운영체제에서 프로세스 스케줄링이 필요한 주된 이유는 무엇입니까?",
    "options": [
      "각 프로세스에 물리적 메모리 프레임을 할당하기 위해", "프로세스들이 CPU를 시간 분할 방식으로 공유하여 CPU 이용률을 극대화하기 위해", "I/O 장치만 효율적으로 사용하기 위해", "가상 주소를 물리 주소로 변환하기 위해"
    ],
    "answer": 2,
    "explanation": "다중 프로그래밍 환경에서 여러 프로세스가 동시에 존재하기 때문에 CPU 스케줄링은 프로세스들이 CPU를 시간 분할 방식으로 공유하여 응답시간을 최적화하고 CPU 사용률을 향상시키는 데 필수적이다【929917391492618†L211-L214】."
  },
  {
    "number": 61,
    "question": "암호학적 해시 함수의 속성 중 하나로, 주어진 해시값에 해당하는 입력 값을 찾기 어렵게 만드는 특성은 무엇입니까?",
    "options": [
      "충돌 저항성", "전방 이미지 저항성(Pre-image resistance)", "2차 전방 이미지 저항성", "무결성"
    ],
    "answer": 2,
    "explanation": "전방 이미지 저항성은 주어진 해시값으로부터 원래의 입력 값을 찾는 것이 계산적으로 불가능하도록 하는 암호학적 해시 함수의 특성이다【501615669944748†L255-L259】."
  },
  {
    "number": 62,
    "question": "암호학적 해시 함수의 2차 전방 이미지 저항성(Second pre-image resistance)에 대한 설명으로 올바른 것은?",
    "options": [
      "임의의 두 입력이 같은 해시값을 갖는 것을 찾기 어렵다", "주어진 입력과 동일한 해시값을 갖는 다른 입력을 찾기 어렵다", "주어진 해시값으로부터 원본 메시지를 찾는 것이 어렵다", "해시 함수는 비대칭 암호화를 지원한다"
    ],
    "answer": 2,
    "explanation": "2차 전방 이미지 저항성은 어떤 입력 M이 주어졌을 때 동일한 해시 값을 생성하는 다른 입력 M'을 찾는 것이 계산적으로 어려워야 한다는 특성이다【501615669944748†L262-L268】."
  },
  {
    "number": 63,
    "question": "두 개의 서로 다른 입력이 같은 해시 값을 갖는 경우를 발견하기 어렵게 만드는 해시 함수의 특성은 무엇입니까?",
    "options": [
      "전방 이미지 저항성", "2차 전방 이미지 저항성", "충돌 저항성", "비밀성"
    ],
    "answer": 3,
    "explanation": "충돌 저항성은 두 개의 다른 입력 메시지가 동일한 해시 값을 갖도록 만드는 것을 계산적으로 어렵게 하는 암호학적 해시 함수의 특성이다【501615669944748†L266-L271】."
  },
  {
    "number": 64,
    "question": "전방 이미지 저항성, 2차 전방 이미지 저항성, 충돌 저항성과 같은 해시 함수의 특성은 무엇을 보장하기 위해 중요합니까?",
    "options": [
      "데이터 기밀성", "데이터 무결성과 보안", "CPU 자원 최적화", "동적 메모리 할당"
    ],
    "answer": 2,
    "explanation": "이러한 속성은 해시 값이 위ㆍ변조되지 않았음을 확인하도록 하여 데이터의 무결성과 보안을 보장하는 데 필수적이다【501615669944748†L280-L286】."
  },
  {
    "number": 65,
    "question": "동일한 비밀 키로 데이터를 암호화하고 복호화하며 대량 데이터 암호화에 적합한 알고리즘은 무엇입니까?",
    "options": [
      "비대칭키 암호화", "해시 암호", "대칭키 암호화", "공개키 서명"
    ],
    "answer": 3,
    "explanation": "대칭키 암호화는 동일한 비밀 키를 사용하여 데이터를 암호화하고 복호화하며 비대칭 방식보다 빠르므로 대량 데이터 암호화에 적합하다【782968811307591†L166-L176】."
  },
  {
    "number": 66,
    "question": "대칭키 암호화 방식의 주요 단점으로 맞는 것은 무엇입니까?",
    "options": [
      "두 개의 키를 사용해야 한다", "공개 키를 사용하기 때문에 느리다", "비밀 키의 공유와 관리가 어렵다", "데이터 무결성을 제공하지 않는다"
    ],
    "answer": 3,
    "explanation": "대칭키 암호화는 동일한 비밀키를 공유해야 하므로 키 분배와 관리가 어렵고 보안에 취약할 수 있다는 단점이 있다【782968811307591†L166-L176】."
  },
  {
    "number": 67,
    "question": "공개키 암호화에서 메시지 암호화와 복호화 방식으로 옳은 것은 무엇입니까?",
    "options": [
      "송신자가 자신의 개인키로 암호화하고 수신자가 자신의 개인키로 복호화한다",
      "송신자가 수신자의 공개키로 암호화하고 수신자가 자신의 개인키로 복호화한다",
      "송신자와 수신자가 동일한 키로 암호화한다",
      "해시 값을 암호화하여 키 분배를 피한다"
    ],
    "answer": 2,
    "explanation": "공개키 암호화에서는 누구나 수신자의 공개키로 메시지를 암호화할 수 있고, 오직 수신자의 개인키로만 복호화할 수 있다【79115765730287†L247-L276】."
  },
  {
    "number": 68,
    "question": "디지털 서명에 대한 설명으로 옳은 것은 무엇입니까?",
    "options": [
      "송신자가 메시지를 공개키로 암호화하여 전송한다",
      "해시 값을 송신자의 개인키로 암호화하여 수신자가 공개키로 검증한다",
      "단방향 해시 함수로만 구성되어 있다",
      "데이터 무결성을 확인할 수 없다"
    ],
    "answer": 2,
    "explanation": "디지털 서명은 메시지의 해시 값을 송신자의 개인키로 암호화한 것으로, 수신자는 송신자의 공개키를 사용해 서명의 진위를 확인하고 메시지가 변경되지 않았음을 검증한다【79115765730287†L247-L276】."
  },
  {
    "number": 69,
    "question": "정보 보안의 CIA 삼원칙 중 기밀성에 대한 설명은 무엇입니까?",
    "options": [
      "정보가 정확하고 완전하게 유지되어야 한다",
      "승인된 사용자만 정보에 접근할 수 있어야 한다",
      "정당한 사용자가 필요할 때 정보를 사용할 수 있어야 한다",
      "데이터가 인증 가능해야 한다"
    ],
    "answer": 2,
    "explanation": "기밀성은 정보가 무단 액세스로부터 보호되어 승인된 사용자만 접근할 수 있도록 하는 것을 의미한다【116221906269427†L204-L208】."
  },
  {
    "number": 70,
    "question": "정보 보안의 삼원칙 중 무결성에 대한 설명은 무엇입니까?",
    "options": [
      "데이터가 승인되지 않은 방식으로 수정되거나 삭제되지 않아야 한다",
      "필요할 때 정보가 항상 사용 가능해야 한다",
      "정보에 접근할 권한이 있는 사람만 접근해야 한다",
      "데이터가 암호화되어야 한다"
    ],
    "answer": 1,
    "explanation": "무결성은 데이터가 승인되지 않은 변경이나 파괴로부터 보호되어 정확하고 완전하게 유지되는 것을 의미한다【116221906269427†L204-L208】."
  },
  {
    "number": 71,
    "question": "정보 보안의 삼원칙 중 가용성에 대한 설명은 무엇입니까?",
    "options": [
      "승인된 사용자만 정보에 접근할 수 있도록 한다",
      "정보가 적시에 접근 가능하고 사용할 수 있어야 한다",
      "데이터가 위변조 없이 정확해야 한다",
      "데이터가 암호화되어야 한다"
    ],
    "answer": 2,
    "explanation": "가용성은 승인된 사용자가 필요할 때 정보와 자원을 이용할 수 있어야 함을 의미한다【116221906269427†L204-L208】."
  },
  {
    "number": 72,
    "question": "패스워드 외에 토큰, 지문 등 두 개 이상의 독립적인 인증 요소를 요구하는 인증 방식은 무엇입니까?",
    "options": [
      "단일 인증", "다중 요소 인증(MFA)", "지문 인증", "질문 인증"
    ],
    "answer": 2,
    "explanation": "다중 요소 인증은 사용자가 알고 있는 것(비밀번호), 가지고 있는 것(토큰), 신체적 특성(생체 정보) 등 서로 독립적인 범주의 요소들을 조합해 사용자의 신원을 확인한다【595613543490340†L82-L96】."
  },
  {
    "number": 73,
    "question": "신뢰할 수 있는 웹 사이트에 악의적인 스크립트를 삽입하여 사용자의 브라우저에서 실행되도록 하는 공격 유형은 무엇입니까?",
    "options": [
      "SQL 인젝션", "크로스 사이트 스크립팅(XSS)", "크로스 사이트 요청 위조(CSRF)", "버퍼 오버플로우"
    ],
    "answer": 2,
    "explanation": "크로스 사이트 스크립팅(XSS) 공격은 웹 애플리케이션에 악성 스크립트를 주입하여 피해자의 브라우저에서 실행하게 만들어 쿠키나 세션 토큰을 탈취하는 공격이다【684727706474785†L34-L49】."
  },
  {
    "number": 74,
    "question": "공격자가 통신 중인 두 당사자 사이에 침입하여 메시지를 중간에서 가로채고 수정하거나 도청하는 공격은 무엇입니까?",
    "options": [
      "서비스 거부 공격(DoS)", "중간자 공격(Man-in-the-Middle)", "피싱", "크로스 사이트 스크립팅"
    ],
    "answer": 2,
    "explanation": "중간자 공격은 통신하는 두 주체 사이에 공격자가 끼어들어 데이터를 가로채고 변조하면서도 당사자들은 서로 직접 통신한다고 착각하게 만드는 공격이다【254782103578978†L189-L203】."
  },
  {
    "number": 75,
    "question": "네트워크 트래픽을 미리 정의된 규칙에 따라 감시하고 허용되지 않는 패킷을 차단하여 첫 번째 방어선을 형성하는 장비는 무엇입니까?",
    "options": [
      "방화벽(Firewall)", "침입 탐지 시스템(IDS)", "침입 방지 시스템(IPS)", "라우터(Router)"
    ],
    "answer": 1,
    "explanation": "방화벽은 네트워크 경계에서 들어오고 나가는 트래픽을 감시하고 미리 정의된 규칙에 따라 필터링하여 비인가된 패킷을 차단하는 보안 장비이다【323353117250299†L79-L87】."
  },
  {
    "number": 76,
    "question": "네트워크나 시스템에서 악의적 행동과 정책 위반을 모니터링하고 경보를 발송하지만 트래픽을 차단하지 않는 시스템은 무엇입니까?",
    "options": [
      "방화벽", "침입 탐지 시스템(IDS)", "침입 방지 시스템(IPS)", "스위치"
    ],
    "answer": 2,
    "explanation": "IDS는 네트워크 트래픽을 분석해 악의적인 패턴이나 정책 위반을 탐지하고 관리자에게 경고하지만 패킷을 직접 차단하지 않는다【323353117250299†L100-L107】."
  },
  {
    "number": 77,
    "question": "실시간 트래픽을 분석하고 악성 패킷을 자동으로 차단함으로써 공격을 예방하는 네트워크 보안 시스템은 무엇입니까?",
    "options": [
      "라우터", "방화벽", "침입 탐지 시스템", "침입 방지 시스템"
    ],
    "answer": 4,
    "explanation": "침입 방지 시스템(IPS)은 IDS와 달리 트래픽을 분석한 후 탐지된 악성 패킷을 실시간으로 차단하여 위협을 방지한다【323353117250299†L110-L118】."
  },
  {
    "number": 78,
    "question": "클라이언트-서버 구조에서 IP 주소와 기타 네트워크 구성을 자동으로 할당하여 사용자 설정 부담을 줄이는 프로토콜은 무엇입니까?",
    "options": [
      "ARP", "DHCP", "NAT", "DNS"
    ],
    "answer": 2,
    "explanation": "DHCP는 클라이언트-서버 모델을 이용해 IP 주소와 서브넷 마스크, 기본 게이트웨이 등 네트워크 설정 정보를 자동으로 할당한다【434033080388175†L268-L283】."
  },
  {
    "number": 79,
    "question": "사설 네트워크의 여러 장치가 하나의 공인 IP 주소를 공유하도록 하여 IPv4 주소 공간을 절약하는 기술은 무엇입니까?",
    "options": [
      "DHCP", "DNS", "NAT", "BGP"
    ],
    "answer": 3,
    "explanation": "NAT는 패킷 헤더의 IP 주소를 변환하여 하나의 공인 IP 주소를 여러 내부 장치에 매핑함으로써 IPv4 주소를 절약한다【929080275383173†L189-L198】."
  },
  {
    "number": 80,
    "question": "여러 사설 IP 주소를 하나의 공인 IP 주소로 변환할 때 각 연결마다 다른 포트 번호를 사용하는 NAT 기법을 무엇이라고 합니까?",
    "options": [
      "1대1 NAT", "포트 주소 변환(PAT)", "정적 NAT", "더블 NAT"
    ],
    "answer": 2,
    "explanation": "포트 주소 변환(PAT)은 사설 네트워크의 여러 호스트가 하나의 공인 IP를 공유하면서 각 호스트의 세션을 다른 포트 번호에 매핑해 구분한다【929080275383173†L245-L279】."
  },
  {
    "number": 81,
    "question": "OSI 모델에서 물리적 매체를 통해 비트 스트림을 송수신하며, 전압 수준과 전송 모드 등을 정의하는 계층은 무엇입니까?",
    "options": [
      "물리 계층", "데이터링크 계층", "네트워크 계층", "전송 계층"
    ],
    "answer": 1,
    "explanation": "물리 계층은 케이블과 커넥터 등 물리적 매체를 통해 전기적/광학적 신호로 비트 스트림을 송수신하며 전압 수준과 전송 모드(단방향, 반이중, 전이중)를 정의한다【311895453899364†L536-L546】."
  },
  {
    "number": 82,
    "question": "노드 간의 프레임 전송, 오류 검출 및 흐름 제어를 담당하는 OSI 계층은 무엇입니까?",
    "options": [
      "물리 계층", "데이터링크 계층", "네트워크 계층", "응용 계층"
    ],
    "answer": 2,
    "explanation": "데이터링크 계층은 인접한 노드 간의 데이터 프레임 전달을 담당하며 오류 검출과 재전송, 흐름 제어를 수행한다【311895453899364†L567-L578】."
  },
  {
    "number": 83,
    "question": "패킷을 다른 네트워크로 전달하고 경로 선택, 패킷 분할/재조립 등을 수행하는 OSI 모델의 계층은 무엇입니까?",
    "options": [
      "네트워크 계층", "전송 계층", "세션 계층", "데이터링크 계층"
    ],
    "answer": 1,
    "explanation": "네트워크 계층은 다양한 네트워크 사이에서 패킷을 전달하고 라우팅 및 패킷 분할ㆍ재조립을 수행한다【311895453899364†L604-L615】."
  },
  {
    "number": 84,
    "question": "엔드 투 엔드 통신 서비스를 제공하고 세그먼트화 및 재조립, 신뢰성 있는 전송 등을 수행하는 OSI 계층은 무엇입니까?",
    "options": [
      "전송 계층", "네트워크 계층", "데이터링크 계층", "물리 계층"
    ],
    "answer": 1,
    "explanation": "전송 계층은 데이터를 세그먼트화하고 수신 측에서 재조립하며, 연결 지향 또는 비연결 서비스와 흐름/오류 제어를 제공한다【311895453899364†L633-L656】."
  },
  {
    "number": 85,
    "question": "신뢰성 있는 연결 지향 서비스를 제공하며 시퀀스 번호와 확인 응답을 사용해 오류와 흐름을 제어하는 전송 계층 프로토콜은 무엇입니까?",
    "options": [
      "UDP", "TCP", "IP", "ICMP"
    ],
    "answer": 2,
    "explanation": "TCP는 전송 계층의 연결 지향 프로토콜로 시퀀스 번호와 확인 응답을 사용하여 데이터의 순서와 정확성을 보장하고 흐름/오류 제어를 제공한다【411261512903373†L66-L90】."
  },
  {
    "number": 86,
    "question": "헤더가 간단하고 연결 설정이 필요 없으며 낮은 지연을 제공하지만 신뢰성 있는 전송을 보장하지 않는 전송 계층 프로토콜은 무엇입니까?",
    "options": [
      "TCP", "UDP", "FTP", "HTTP"
    ],
    "answer": 2,
    "explanation": "UDP는 전송 계층의 비연결성 프로토콜로 오류 제어나 흐름 제어가 없기 때문에 지연이 적고 단순한 요청-응답 또는 실시간 스트리밍에 적합하다【411261512903373†L124-L144】."
  },
  {
    "number": 87,
    "question": "IPv6의 주소 길이는 몇 비트입니까?",
    "options": [
      "32비트", "64비트", "128비트", "256비트"
    ],
    "answer": 3,
    "explanation": "IPv6 주소는 128비트 길이로, IPv4의 32비트보다 훨씬 큰 주소 공간을 제공한다【330704206992122†L577-L589】."
  },
  {
    "number": 88,
    "question": "IPv6가 IPv4에 비해 갖는 주요 이점은 무엇입니까?",
    "options": [
      "주소 크기가 작아 저장 공간을 절약한다", "더 큰 주소 공간과 효율적 경로 집계가 가능하다", "NAT를 필수로 사용해야 한다", "DNS 사용을 없앤다"
    ],
    "answer": 2,
    "explanation": "IPv6는 128비트 주소 체계를 사용하여 매우 큰 주소 공간을 제공하고, 라우팅 경로 집계를 효율적으로 할 수 있다는 장점이 있다【330704206992122†L577-L589】."
  },
  {
    "number": 89,
    "question": "주소 결정 프로토콜(ARP)의 기본 기능은 무엇입니까?",
    "options": [
      "도메인 이름을 IP 주소로 변환한다", "IP 주소를 물리적 MAC 주소로 변환한다", "동적으로 IP 주소를 할당한다", "패킷을 전송하기 위해 분할한다"
    ],
    "answer": 2,
    "explanation": "ARP는 네트워크 상에서 IP 주소를 MAC(물리) 주소로 변환하기 위해 브로드캐스트 요청을 보내고 응답을 받아 주소를 매핑한다【34165916691922†L157-L164】."
  },
  {
    "number": 90,
    "question": "호스트가 자신의 MAC 주소를 사용해 IP 주소를 얻기 위해 브로드캐스트하는 프로토콜은 무엇입니까?",
    "options": [
      "ARP", "역방향 ARP(RARP)", "DHCP", "ICMP"
    ],
    "answer": 2,
    "explanation": "RARP는 호스트가 자신의 MAC 주소를 이용해 네트워크 상의 RARP 서버에 IP 주소를 요청하여 할당받을 수 있게 해 준다【34165916691922†L157-L164】."
  },
  {
    "number": 91,
    "question": "초기 이더넷에서 사용되던 매체 접근 제어 방식으로, 송신 전에 채널을 감지하고 충돌이 감지되면 전송을 중단하고 재시도하는 것은 무엇입니까?",
    "options": [
      "토큰 링", "CSMA/CD", "TDMA", "FDMA"
    ],
    "answer": 2,
    "explanation": "CSMA/CD(Carrier Sense Multiple Access with Collision Detection)는 모든 장치가 매체를 청취하여 비어 있는 경우 전송하고, 충돌이 발생하면 전송을 중단하고 임의 시간 후 재시도하는 방식이다【825925818238033†L154-L162】."
  },
  {
    "number": 92,
    "question": "CSMA/CD에 대한 설명으로 옳은 것은 무엇입니까?",
    "options": [
      "충돌을 완전히 방지하기 위해 전송 일정을 예약한다", "충돌을 감지하면 재전송 전에 랜덤한 시간을 기다린다", "각 송신자에 전용 채널을 할당한다", "현재의 스위치 기반 이더넷에서 널리 사용된다"
    ],
    "answer": 2,
    "explanation": "CSMA/CD는 충돌이 발생하면 장비가 즉시 전송을 중지하고 짧은 시간 동안 랜덤한 backoff 후 재전송하는 방식이다【825925818238033†L154-L162】."
  },
  {
    "number": 93,
    "question": "데이터링크 계층의 오류 검출 기능의 주된 목적은 무엇입니까?",
    "options": [
      "물리적 신호의 무결성을 보장하기 위해", "전송된 프레임의 오류를 감지하고 재전송 또는 수정하도록 하기 위해", "네트워크 간 패킷 라우팅을 수행하기 위해", "IP 주소를 동적으로 할당하기 위해"
    ],
    "answer": 2,
    "explanation": "데이터링크 계층은 프레임 전송 중 발생할 수 있는 오류를 검출하고, 필요한 경우 상위 계층에 재전송을 요청하거나 수정하는 기능을 제공한다【311895453899364†L567-L578】."
  },
  {
    "number": 94,
    "question": "논리적 주소를 추가하여 데이터 단위를 패킷으로 만들고 여러 네트워크를 통과하도록 경로를 선택하는 OSI 계층은 무엇입니까?",
    "options": [
      "네트워크 계층", "데이터링크 계층", "물리 계층", "응용 계층"
    ],
    "answer": 1,
    "explanation": "네트워크 계층은 패킷에 논리적 주소(IP)를 부여하고 라우팅 기능을 통해 패킷이 여러 네트워크를 거쳐 목적지에 도착하도록 경로를 선택한다【311895453899364†L604-L615】."
  },
  {
    "number": 95,
    "question": "메시지를 세그먼트로 나누어 시퀀스 번호를 할당하고 수신 측에서 재조립하는 등 신뢰성 있는 전송을 제공하는 OSI 계층은 무엇입니까?",
    "options": [
      "전송 계층", "세션 계층", "표현 계층", "물리 계층"
    ],
    "answer": 1,
    "explanation": "전송 계층은 메시지를 세그먼트로 분할하고 각각에 시퀀스 번호를 부여하며 수신자가 순서를 복원할 수 있도록 지원하여 신뢰성 있는 통신을 제공한다【311895453899364†L633-L656】."
  },
  {
    "number": 96,
    "question": "다음 중 TCP와 UDP의 공통점은 무엇입니까?",
    "options": [
      "모두 신뢰성 있고 연결 지향적이다", "둘 다 OSI 모델의 전송 계층에서 동작한다", "둘 다 시퀀스 번호와 확인 응답을 사용한다", "둘 다 3단계 핸드셰이크를 필요로 한다"
    ],
    "answer": 2,
    "explanation": "TCP와 UDP는 모두 OSI 참조 모델의 전송 계층 프로토콜이다. 그러나 TCP는 연결 지향적이고 신뢰성을 제공하는 반면 UDP는 비연결적이다【311895453899364†L633-L656】."
  },
  {
    "number": 97,
    "question": "물리 계층에서 지원하는 전송 모드로 올바른 설명은 무엇입니까?",
    "options": [
      "단방향", "반이중", "전이중", "위의 모든 모드"
    ],
    "answer": 4,
    "explanation": "물리 계층은 단방향, 반이중, 전이중과 같은 다양한 전송 모드를 정의하고 지원한다【311895453899364†L536-L546】."
  },
  {
    "number": 98,
    "question": "NAT를 사용하면 여러 장치가 하나의 공인 IP 주소를 공유할 수 있다. 이것이 IPv4 주소 공간에 미치는 영향은 무엇입니까?",
    "options": [
      "공인 IPv4 주소 수요를 증가시킨다", "공인 IPv4 주소를 절약하여 주소 공간 고갈 문제를 완화한다", "사설 IP 주소의 필요성을 없앤다", "네트워크 보안이 저하된다"
    ],
    "answer": 2,
    "explanation": "NAT는 여러 사설 IP를 단일 공인 IP로 매핑하여 IPv4 주소를 절약하고 주소 공간 부족 문제를 완화한다【929080275383173†L189-L198】."
  },
  {
    "number": 99,
    "question": "IP 주소뿐 아니라 서브넷 마스크, 기본 게이트웨이 등 네트워크 구성 매개변수를 동적으로 할당하는 프로토콜은 무엇입니까?",
    "options": [
      "DNS", "DHCP", "ARP", "NAT"
    ],
    "answer": 2,
    "explanation": "DHCP는 클라이언트가 네트워크에 접속할 때 IP 주소와 서브넷 마스크, 기본 게이트웨이 등 네트워크 설정을 자동으로 할당한다【434033080388175†L268-L283】."
  },
  {
    "number": 100,
    "question": "IPv4 네트워크에서 NAT가 널리 사용되는 주요 이유는 무엇입니까?",
    "options": [
      "데이터 암호화를 강화하기 위해", "제한된 IPv4 주소 공간을 극복하기 위해 여러 장치가 하나의 공인 IP를 공유하도록 하기 위해", "전송 속도를 높이기 위해", "오류 제어를 구현하기 위해"
    ],
    "answer": 2,
    "explanation": "IPv4 주소 공간이 제한되어 있기 때문에 NAT를 통해 여러 사설 네트워크 장치가 하나의 공인 IP 주소를 공유할 수 있어 주소 고갈 문제를 해결한다【929080275383173†L189-L198】【929080275383173†L245-L279】."
  }
];

    const container = document.getElementById("quiz-container");

    // Fisher–Yates Shuffle
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // 퀴즈 순서 무작위화
    const shuffledQuizData = shuffleArray([...quizData]);

    shuffledQuizData.forEach(q => {
      const div = document.createElement("div");
      div.className = "question";
      div.dataset.answer = q.answer;
      div.dataset.explanation = q.explanation;

      const h3 = document.createElement("h3");
      h3.innerText = `${q.number}. ${q.question}`;

      const optionsDiv = document.createElement("div");
      optionsDiv.className = "options";

      q.options.forEach((opt, idx) => {
        const label = document.createElement("label");
        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = `q${q.number}`;
        radio.value = (idx + 1).toString(); // ✅ value 꼭 설정
        label.appendChild(radio);
        label.append(` ${String.fromCharCode(9312 + idx)} ${opt}`);
        optionsDiv.appendChild(label);
      });

      const btn = document.createElement("button");
      btn.innerText = "정답 확인";
      btn.onclick = function () {
      const radios = div.querySelectorAll('input[type=radio]');
      const answerDiv = div.querySelector('.answer');
      let selectedIdx = -1;

      radios.forEach((radio, idx) => {
        if (radio.checked) selectedIdx = idx + 1;
      });

      radios.forEach((radio, idx) => {
        const label = radio.parentElement;
        label.classList.remove('correct', 'wrong', 'right');

        if ((idx + 1).toString() === div.dataset.answer) {
          if (selectedIdx.toString() === div.dataset.answer) {
            label.style.color = 'blue'; // 정답을 맞춘 경우 파란색
          } else {
            label.style.color = 'red'; // 틀린 경우 정답만 빨간색
          }
        } else {
          label.style.color = ''; // 다른 보기는 색 없앰
        }
      });

      if (answerDiv.style.display === 'none' || answerDiv.style.display === '') {
        answerDiv.innerHTML = `<strong>정답:</strong> ${div.dataset.answer}번<br><em>${div.dataset.explanation}</em>`;
        answerDiv.style.display = 'block';
      } else {
        answerDiv.style.display = 'none';
      }
    };

      const answerDiv = document.createElement("div");
      answerDiv.className = "answer";

      div.appendChild(h3);
      div.appendChild(optionsDiv);
      div.appendChild(btn);
      div.appendChild(answerDiv);

      container.appendChild(div);
    });

    // ✅ 결과보기 버튼 클릭 시 전체 채점
    document.getElementById("check-all").addEventListener("click", function () {
      let score = 0;
      quizData.forEach(q => {
        const selected = document.querySelector(`input[name="q${q.number}"]:checked`);
        if (selected && selected.value === q.answer.toString()) {
          score++;
        }
      });
      document.getElementById("score").textContent = `당신의 점수는 ${score} / ${quizData.length} 입니다.`;
    });
  </script>
</body>
</html>
